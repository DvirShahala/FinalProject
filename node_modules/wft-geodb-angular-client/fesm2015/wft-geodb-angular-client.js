import { HttpClient, HttpParams, HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { Injectable, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GeoDbConfig {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GeoDbService {
    /**
     * @param {?} httpClient
     * @param {?} config
     */
    constructor(httpClient, config) {
        this.httpClient = httpClient;
        this.config = config;
        this.adminDivisionsEndpoint = config.serviceUri + 'v1/geo/adminDivisions';
        this.countriesEndpoint = config.serviceUri + '/v1/geo/countries';
        this.currenciesEndpoint = config.serviceUri + '/v1/locale/currencies';
        this.languagesEndpoint = config.serviceUri + '/v1/locale/languages';
        this.localesEndpoint = config.serviceUri + '/v1/locale/locales';
        this.placesEndpoint = config.serviceUri + '/v1/geo/cities';
        this.timeZonesEndpoint = config.serviceUri + '/v1/locale/timezones';
    }
    /**
     * @private
     * @param {?} request
     * @return {?}
     */
    static buildPagingParams(request) {
        return new HttpParams()
            .set('offset', '' + request.offset)
            .set('limit', '' + request.limit)
            .set('hateoasMode', 'false');
    }
    /**
     * @private
     * @param {?} nearLocation
     * @return {?}
     */
    static toLocationString(nearLocation) {
        /** @type {?} */
        let locationString = '';
        if (nearLocation.latitude > 0) {
            locationString += '+';
        }
        locationString += nearLocation.latitude;
        if (nearLocation.longitude > 0) {
            locationString += '+';
        }
        locationString += nearLocation.longitude;
        return locationString;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    findAdminDivisions(request) {
        /** @type {?} */
        let params = GeoDbService.buildPagingParams(request);
        if (request.countryIds) {
            params = params.set('countryIds', request.countryIds.join(','));
        }
        if (request.excludedCountryIds) {
            params = params.set('excludedCountryIds', request.excludedCountryIds.join(','));
        }
        if (request.namePrefix) {
            params = params.set('namePrefix', request.namePrefix);
        }
        if (request.minPopulation) {
            params = params.set('minPopulation', '' + request.minPopulation);
        }
        if (request.timeZoneIds) {
            params = params.set('timeZoneIds', request.timeZoneIds.join(','));
        }
        if (request.asciiMode) {
            params = params.set('asciiMode', '' + request.asciiMode);
        }
        if (request.languageCode) {
            params = params.set('languageCode', request.languageCode);
        }
        if (request.sortDirectives) {
            params = params.set('sort', request.sortDirectives.join(','));
        }
        if (request.includeDeleted) {
            params = params.set('includeDeleted', request.includeDeleted);
        }
        return this.httpClient.get(this.adminDivisionsEndpoint, {
            params: params
        });
    }
    /**
     * @param {?} request
     * @return {?}
     */
    findPlace(request) {
        /** @type {?} */
        const endpoint = this.buildPlaceEndpoint(request.placeId);
        /** @type {?} */
        let params = new HttpParams();
        if (request.asciiMode) {
            params = params.set('asciiMode', '' + request.asciiMode);
        }
        if (request.languageCode) {
            params = params.set('languageCode', request.languageCode);
        }
        return this.httpClient.get(endpoint, {
            params: params
        });
    }
    /**
     * @param {?} request
     * @return {?}
     */
    findPlaces(request) {
        /** @type {?} */
        let params = GeoDbService.buildPagingParams(request);
        if (request.countryIds) {
            params = params.set('countryIds', request.countryIds.join(','));
        }
        if (request.excludedCountryIds) {
            params = params.set('excludedCountryIds', request.excludedCountryIds.join(','));
        }
        if (request.namePrefix) {
            params = params.set('namePrefix', request.namePrefix);
        }
        if (request.minPopulation) {
            params = params.set('minPopulation', '' + request.minPopulation);
        }
        if (request.timeZoneIds) {
            params = params.set('timeZoneIds', request.timeZoneIds.join(','));
        }
        if (request.types) {
            params = params.set('types', request.types.join(','));
        }
        if (request.asciiMode) {
            params = params.set('asciiMode', '' + request.asciiMode);
        }
        if (request.languageCode) {
            params = params.set('languageCode', request.languageCode);
        }
        if (request.sortDirectives) {
            params = params.set('sort', request.sortDirectives.join(','));
        }
        if (request.includeDeleted) {
            params = params.set('includeDeleted', request.includeDeleted);
        }
        return this.httpClient.get(this.placesEndpoint, {
            params: params
        });
    }
    /**
     * @param {?} request
     * @return {?}
     */
    findPlacesNearLocation(request) {
        /** @type {?} */
        let params = GeoDbService.buildPagingParams(request);
        params = params
            .set('radius', '' + request.location.radius)
            .set('distanceUnit', request.location.distanceUnit);
        if (request.minPopulation) {
            params = params.set('minPopulation', '' + request.minPopulation);
        }
        if (request.namePrefix) {
            params = params.set('namePrefix', request.namePrefix);
        }
        if (request.types) {
            params = params.set('types', request.types.join(','));
        }
        if (request.asciiMode) {
            params = params.set('asciiMode', '' + request.asciiMode);
        }
        if (request.languageCode) {
            params = params.set('languageCode', request.languageCode);
        }
        if (request.sortDirectives) {
            params = params.set('sort', request.sortDirectives.join(','));
        }
        if (request.includeDeleted) {
            params = params.set('includeDeleted', request.includeDeleted);
        }
        // Workaround for HttpClient '+' encoding bug.
        /** @type {?} */
        const locationId = GeoDbService
            .toLocationString(request.location)
            .replace('+', '%2B');
        /** @type {?} */
        const endpoint = this.placesEndpoint + '?location=' + locationId;
        return this.httpClient.get(endpoint, {
            params: params
        });
    }
    /**
     * @param {?} request
     * @return {?}
     */
    findPlacesNearPlace(request) {
        /** @type {?} */
        let params = GeoDbService.buildPagingParams(request);
        params = params
            .set('radius', '' + request.radius)
            .set('distanceUnit', request.distanceUnit);
        if (request.minPopulation) {
            params = params.set('minPopulation', '' + request.minPopulation);
        }
        if (request.types) {
            params = params.set('types', request.types.join(','));
        }
        if (request.asciiMode) {
            params = params.set('asciiMode', '' + request.asciiMode);
        }
        if (request.languageCode) {
            params = params.set('languageCode', request.languageCode);
        }
        if (request.sortDirectives) {
            params = params.set('sort', request.sortDirectives.join(','));
        }
        if (request.includeDeleted) {
            params = params.set('includeDeleted', request.includeDeleted);
        }
        /** @type {?} */
        const endpoint = this.placesEndpoint + '/' + request.placeId + '/nearbyCities';
        return this.httpClient.get(endpoint, {
            params: params
        });
    }
    /**
     * @param {?} request
     * @return {?}
     */
    findCountries(request) {
        /** @type {?} */
        let params = GeoDbService.buildPagingParams(request);
        if (request.currencyCode) {
            params = params.set('currencyCode', request.currencyCode);
        }
        if (request.namePrefix) {
            params = params.set('namePrefix', request.namePrefix);
        }
        if (request.asciiMode) {
            params = params.set('asciiMode', '' + request.asciiMode);
        }
        if (request.languageCode) {
            params = params.set('languageCode', request.languageCode);
        }
        return this.httpClient.get(this.countriesEndpoint, {
            params: params
        });
    }
    /**
     * @param {?} request
     * @return {?}
     */
    findCountry(request) {
        /** @type {?} */
        const endpoint = this.countriesEndpoint + '/' + request.countryId;
        /** @type {?} */
        let params = new HttpParams();
        if (request.asciiMode) {
            params = params.set('asciiMode', '' + request.asciiMode);
        }
        if (request.languageCode) {
            params = params.set('languageCode', request.languageCode);
        }
        return this.httpClient.get(endpoint, {
            params: params
        });
    }
    /**
     * @param {?} request
     * @return {?}
     */
    findCurrencies(request) {
        /** @type {?} */
        let params = GeoDbService.buildPagingParams(request);
        if (request.countryId) {
            params = params.set('countryId', request.countryId);
        }
        return this.httpClient.get(this.currenciesEndpoint, {
            params: params
        });
    }
    /**
     * @param {?} request
     * @return {?}
     */
    findLanguages(request) {
        /** @type {?} */
        const params = GeoDbService.buildPagingParams(request);
        return this.httpClient.get(this.languagesEndpoint, {
            params: params
        });
    }
    /**
     * @param {?} request
     * @return {?}
     */
    findLocales(request) {
        /** @type {?} */
        const params = GeoDbService.buildPagingParams(request);
        return this.httpClient.get(this.localesEndpoint, {
            params: params
        });
    }
    /**
     * @param {?} request
     * @return {?}
     */
    findRegion(request) {
        /** @type {?} */
        const endpoint = this.buildRegionsEndpoint(request.countryId) + '/' + request.regionCode;
        /** @type {?} */
        let params = new HttpParams();
        if (request.asciiMode) {
            params = params.set('asciiMode', '' + request.asciiMode);
        }
        if (request.languageCode) {
            params = params.set('languageCode', request.languageCode);
        }
        return this.httpClient.get(endpoint, {
            params: params
        });
    }
    /**
     * @param {?} request
     * @return {?}
     */
    findRegionPlaces(request) {
        /** @type {?} */
        const endpoint = this.buildRegionEndpoint(request.countryId, request.regionCode) + '/cities';
        /** @type {?} */
        let params = GeoDbService.buildPagingParams(request);
        if (request.minPopulation) {
            params = params.set('minPopulation', '' + request.minPopulation);
        }
        if (request.types) {
            params = params.set('types', request.types.join(','));
        }
        if (request.asciiMode) {
            params = params.set('asciiMode', '' + request.asciiMode);
        }
        if (request.languageCode) {
            params = params.set('languageCode', request.languageCode);
        }
        if (request.sortDirectives) {
            params = params.set('sort', request.sortDirectives.join(','));
        }
        return this.httpClient.get(endpoint, {
            params: params
        });
    }
    /**
     * @param {?} request
     * @return {?}
     */
    findRegions(request) {
        /** @type {?} */
        const endpoint = this.buildRegionsEndpoint(request.countryId);
        /** @type {?} */
        let params = GeoDbService.buildPagingParams(request);
        if (request.namePrefix) {
            params = params.set('namePrefix', request.namePrefix);
        }
        if (request.asciiMode) {
            params = params.set('asciiMode', '' + request.asciiMode);
        }
        if (request.languageCode) {
            params = params.set('languageCode', request.languageCode);
        }
        return this.httpClient.get(endpoint, {
            params: params
        });
    }
    /**
     * @param {?} request
     * @return {?}
     */
    findTimeZones(request) {
        /** @type {?} */
        const params = GeoDbService.buildPagingParams(request);
        return this.httpClient.get(this.timeZonesEndpoint, {
            params: params
        });
    }
    /**
     * @return {?}
     */
    get apiKey() {
        return this.config.apiKey;
    }
    /**
     * @param {?} apiKey
     * @return {?}
     */
    setApiKey(apiKey) {
        this.config.apiKey = apiKey;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getPlaceDateTime(id) {
        /** @type {?} */
        const endpoint = this.buildPlaceEndpoint(id) + '/dateTime';
        return this.httpClient.get(endpoint);
    }
    /**
     * @param {?} request
     * @return {?}
     */
    getPlaceDistance(request) {
        /** @type {?} */
        const endpoint = this.buildPlaceEndpoint(request.toPlaceId) + '/distance';
        /** @type {?} */
        const params = new HttpParams()
            .set('fromPlaceId', '' + request.fromPlaceId)
            .set('distanceUnit', '' + request.distanceUnit);
        return this.httpClient.get(endpoint, {
            params: params
        });
    }
    /**
     * @param {?} placeId
     * @return {?}
     */
    getPlaceTime(placeId) {
        /** @type {?} */
        const endpoint = this.buildPlaceEndpoint(placeId) + '/time';
        return this.httpClient.get(endpoint);
    }
    /**
     * @param {?} zoneId
     * @return {?}
     */
    getTimeZoneDateTime(zoneId) {
        /** @type {?} */
        const endpoint = this.buildTimeZoneEndpoint(zoneId) + '/dateTime';
        return this.httpClient.get(endpoint);
    }
    /**
     * @param {?} zoneId
     * @return {?}
     */
    getTimeZoneTime(zoneId) {
        /** @type {?} */
        const endpoint = this.buildTimeZoneEndpoint(zoneId) + '/time';
        return this.httpClient.get(endpoint);
    }
    /**
     * @private
     * @param {?} olaceId
     * @return {?}
     */
    buildPlaceEndpoint(olaceId) {
        return this.placesEndpoint + '/' + olaceId;
    }
    /**
     * @private
     * @param {?} countryId
     * @param {?} regionCode
     * @return {?}
     */
    buildRegionEndpoint(countryId, regionCode) {
        return this.buildRegionsEndpoint(countryId) + '/' + regionCode;
    }
    /**
     * @private
     * @param {?} countryId
     * @return {?}
     */
    buildRegionsEndpoint(countryId) {
        return this.countriesEndpoint + '/' + countryId + '/regions';
    }
    /**
     * @private
     * @param {?} zoneId
     * @return {?}
     */
    buildTimeZoneEndpoint(zoneId) {
        return this.timeZonesEndpoint + '/' + zoneId;
    }
}
GeoDbService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
GeoDbService.ctorParameters = () => [
    { type: HttpClient },
    { type: GeoDbConfig }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GeoDbFreeModule {
    /**
     * @param {?} config
     */
    constructor(config) {
    }
    /**
     * @param {?} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: GeoDbFreeModule,
            providers: [
                { provide: GeoDbConfig, useValue: config }
            ]
        };
    }
}
GeoDbFreeModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    GeoDbService
                ],
                imports: [
                    HttpClientModule
                ]
            },] }
];
/** @nocollapse */
GeoDbFreeModule.ctorParameters = () => [
    { type: GeoDbConfig }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthInterceptor {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        if (request.url.startsWith(this.config.serviceUri)) {
            /** @type {?} */
            const headers = request
                .headers
                .set('X-Mashape-Key', this.config.apiKey);
            return next.handle(request.clone({ headers: headers }));
        }
        return next.handle(request);
    }
}
AuthInterceptor.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AuthInterceptor.ctorParameters = () => [
    { type: GeoDbConfig }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GeoDbProModule {
    /**
     * @param {?} config
     */
    constructor(config) {
    }
    /**
     * @param {?} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: GeoDbProModule,
            providers: [
                { provide: GeoDbConfig, useValue: config }
            ]
        };
    }
}
GeoDbProModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    GeoDbService,
                    {
                        provide: HTTP_INTERCEPTORS,
                        useClass: AuthInterceptor,
                        multi: true
                    }
                ],
                imports: [
                    HttpClientModule
                ]
            },] }
];
/** @nocollapse */
GeoDbProModule.ctorParameters = () => [
    { type: GeoDbConfig }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { GeoDbFreeModule, GeoDbProModule, GeoDbService, AuthInterceptor as ɵb, GeoDbConfig as ɵa };

//# sourceMappingURL=wft-geodb-angular-client.js.map